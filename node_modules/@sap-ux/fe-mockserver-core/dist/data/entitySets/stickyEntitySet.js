"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StickyMockEntitySet = void 0;
const entitySet_1 = require("./entitySet");
const lodash_clonedeep_1 = __importDefault(require("lodash.clonedeep"));
const common_1 = require("../common");
/**
 *
 */
class StickyMockEntitySet extends entitySet_1.MockDataEntitySet {
    constructor(rootFolder, entitySetDefinition, dataAccess, generateMockData) {
        super(rootFolder, entitySetDefinition, dataAccess, generateMockData);
        this._currentSessionObject = {};
        this.sessionTimeoutTime = 120;
    }
    getSessionObject(tenantId) {
        return this._currentSessionObject[tenantId];
    }
    setSessionObject(tenantId, objectData) {
        this._currentSessionObject[tenantId] = objectData;
    }
    resetSessionTimeout(tenantId) {
        clearTimeout(this.sessionTimeoutRef);
        this.sessionTimeoutRef = setTimeout(() => {
            this.currentUUID = undefined;
            this.setSessionObject(tenantId, null);
        }, this.sessionTimeoutTime * 1000);
        return this.currentUUID;
    }
    async performPATCH(keyValues, patchData, tenantId, odataRequest) {
        keyValues = this.prepareKeys(keyValues);
        const data = this.performGET(keyValues, false, tenantId, odataRequest);
        const currentMockData = this.getMockData(tenantId);
        const updatedData = Object.assign(data, patchData);
        await currentMockData.onBeforeUpdateEntry(keyValues, updatedData, odataRequest);
        if (updatedData.__transient) {
            this.setSessionObject(tenantId, updatedData);
        }
        else {
            await currentMockData.updateEntry(keyValues, updatedData, patchData, odataRequest);
        }
        await currentMockData.onAfterUpdateEntry(keyValues, updatedData, odataRequest);
        return updatedData;
    }
    async executeAction(actionDefinition, actionData, odataRequest, keys) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
        const currentMockData = this.getMockData(odataRequest.tenantId);
        keys = this.prepareKeys(keys);
        actionData = await currentMockData.onBeforeAction(actionDefinition, actionData, keys, odataRequest);
        let responseObject;
        switch (actionDefinition.fullyQualifiedName) {
            // Draft Edit Action
            case `${(_d = (_c = (_b = (_a = this.entitySetDefinition) === null || _a === void 0 ? void 0 : _a.annotations) === null || _b === void 0 ? void 0 : _b.Session) === null || _c === void 0 ? void 0 : _c.StickySessionSupported) === null || _d === void 0 ? void 0 : _d.EditAction}(${actionDefinition.sourceType})`: {
                const data = this.performGET(keys, false, odataRequest.tenantId, odataRequest);
                const duplicate = Object.assign({}, data);
                this.setSessionObject(odataRequest.tenantId, duplicate);
                this.addSessionToken(odataRequest);
                duplicate.__transient = true;
                duplicate.__keys = keys;
                responseObject = duplicate;
                break;
            }
            case `${(_h = (_g = (_f = (_e = this.entitySetDefinition) === null || _e === void 0 ? void 0 : _e.annotations) === null || _f === void 0 ? void 0 : _f.Session) === null || _g === void 0 ? void 0 : _g.StickySessionSupported) === null || _h === void 0 ? void 0 : _h.NewAction}(${actionDefinition.sourceType})`: {
                // New
                const newObject = Object.assign({}, actionData);
                const nonNullableProperties = (_j = actionDefinition.returnEntityType) === null || _j === void 0 ? void 0 : _j.entityProperties.filter((prop) => prop.nullable === false);
                nonNullableProperties === null || nonNullableProperties === void 0 ? void 0 : nonNullableProperties.forEach((nonNullableProperty) => {
                    if (newObject[nonNullableProperty.name] === undefined) {
                        switch (nonNullableProperty.type) {
                            case 'Edm.String':
                            case 'Edm.Guid':
                                newObject[nonNullableProperty.name] = (nonNullableProperty === null || nonNullableProperty === void 0 ? void 0 : nonNullableProperty.defaultValue) || '';
                                break;
                            default:
                                newObject[nonNullableProperty.name] = nonNullableProperty === null || nonNullableProperty === void 0 ? void 0 : nonNullableProperty.defaultValue;
                                break;
                        }
                    }
                });
                this.setSessionObject(odataRequest.tenantId, newObject);
                newObject.__transient = true;
                odataRequest.setContext(`../$metadata#${(_k = this.entitySetDefinition) === null || _k === void 0 ? void 0 : _k.name}()/$entity`);
                this.addSessionToken(odataRequest);
                this.resetSessionTimeout(odataRequest.tenantId);
                responseObject = newObject;
                break;
            }
            case `${(_p = (_o = (_m = (_l = this.entitySetDefinition) === null || _l === void 0 ? void 0 : _l.annotations) === null || _m === void 0 ? void 0 : _m.Session) === null || _o === void 0 ? void 0 : _o.StickySessionSupported) === null || _p === void 0 ? void 0 : _p.DiscardAction}(${actionDefinition.sourceType})`:
                // Discard
                this.setSessionObject(odataRequest.tenantId, null);
                responseObject = null;
                break;
            case `${(_t = (_s = (_r = (_q = this.entitySetDefinition) === null || _q === void 0 ? void 0 : _q.annotations) === null || _r === void 0 ? void 0 : _r.Session) === null || _s === void 0 ? void 0 : _s.StickySessionSupported) === null || _t === void 0 ? void 0 : _t.SaveAction}(${actionDefinition.sourceType})`: {
                const newData = this.getSessionObject(odataRequest.tenantId);
                if (newData.__keys) {
                    // Key needs to be filled now
                    await currentMockData.updateEntry(newData.__keys, newData, newData, odataRequest);
                }
                else {
                    await this.performPOST({}, newData, odataRequest.tenantId, odataRequest);
                }
                this.setSessionObject(odataRequest.tenantId, null);
                responseObject = newData;
                break;
            }
            default:
                break;
        }
        responseObject = await currentMockData.onAfterAction(actionDefinition, actionData, keys, responseObject, odataRequest);
        return responseObject;
    }
    addSessionToken(odataRequest) {
        const uuid = (0, common_1.generateId)(16);
        this.currentUUID = uuid;
        odataRequest.addResponseHeader('sap-contextid', 'SID:ANON:' + uuid);
        odataRequest.addResponseHeader('sap-http-session-timeout', this.sessionTimeoutTime.toString());
    }
    performGET(keyValues, asArray, tenantId, odataRequest, dontClone = false) {
        const currentSessionObject = this.getSessionObject(tenantId);
        if (currentSessionObject && keyValues && Object.keys(keyValues).length) {
            if ((Object.prototype.hasOwnProperty.call(keyValues, "''") && keyValues["''"] === undefined) ||
                this.checkKeys(keyValues, currentSessionObject, this.entityTypeDefinition.keys)) {
                if (odataRequest) {
                    odataRequest.addResponseHeader('sap-contextid', 'SID:ANON:' + this.currentUUID);
                    odataRequest.addResponseHeader('sap-http-session-timeout', this.sessionTimeoutTime.toString());
                }
                this.resetSessionTimeout(tenantId);
                return (0, lodash_clonedeep_1.default)(currentSessionObject);
            }
        }
        return super.performGET(keyValues, asArray, tenantId, odataRequest, dontClone);
    }
}
exports.StickyMockEntitySet = StickyMockEntitySet;
//# sourceMappingURL=stickyEntitySet.js.map